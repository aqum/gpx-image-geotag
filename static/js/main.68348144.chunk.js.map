{"version":3,"sources":["gpx-form/gpx-form.component.tsx","message-box/assets/icon.svg","message-box/message-box.component.tsx","images-form/images-form.component.tsx","geotag-download/geotag-download.component.tsx","correlate-step/offset-control/offset-control.component.tsx","correlate-step/images-map/images-map.component.tsx","correlate-step/correlate-step.component.tsx","app.component.tsx","index.tsx"],"names":["GpxForm","props","handleFileChange","bind","event","files","target","this","onChange","convertFileToGpxPoints","points","type","accept","file","reader","FileReader","Promise","resolve","reject","onload","xmlParser","result","attributeNamePrefix","ignoreAttributes","gpx","trk","trkseg","trkpt","map","rawPoint","lat","parseFloat","lon","ele","time","Date","onerror","onabort","readAsText","Component","_extends","Object","assign","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","_objectWithoutProperties","excluded","sourceKeys","keys","indexOf","_objectWithoutPropertiesLoose","getOwnPropertySymbols","sourceSymbolKeys","propertyIsEnumerable","_ref2","createElement","d","_ref","svgRef","title","width","height","viewBox","ref","ForwardRef","forwardRef","MessageBox","className","text","ImagesForm","handleImageChange","onImagesChange","imageFilesPromises","Array","from","convertFileToDataUrl","all","imageFiles","imagesPromises","imageFile","a","resizeImage","dataUrl","name","lastModified","thumbnailUrl","originalDataUrl","exifData","piexifjs","latDms","GPS","GPSLatitude","lonDms","GPSLongitude","dmsRationalToDeg","gps","images","multiple","url","maxWidth","maxHeight","sourceImage","Image","proportionRatio","proportionalWidth","proportionalHeight","canvas","document","context","getContext","drawImage","toDataURL","src","readAsDataURL","GeotagDownload","handleDownload","zip","JSZip","image","createBlobWithGps","blob","fileName","generateAsync","zipBlob","saveAs","onClick","degToDmsRational","GPSVersionID","GPSLatitudeRef","GPSLongitudeRef","exifStr","updatedDataUrl","fetch","then","res","updatedBlob","OffsetControl","state","offset","handleOffsetChange","handleOffsetDiff","value","parseInt","setState","offsetDiff","newOffset","L","Icon","Default","_getIconUrl","mergeOptions","iconRetinaUrl","require","iconUrl","shadowUrl","ImagesMap","linePoints","point","bounds","Map","TileLayer","attribution","Polyline","positions","filter","Marker","position","Popup","alt","CorrelateStep","imagesOutsideRange","onOffsetChange","App","handleImagesChange","handleGpxChange","offsetSecs","updateImagesLocation","imagesWithGpx","attachGpsCoordinates","href","lastModifiedWithOffset","getTime","timeframeSortedPoints","sort","pointA","pointB","calculateTimeframeSecs","closestPoint","maxGpsTimeframeSecs","undefined","Math","abs","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.68348144.chunk.js","sourcesContent":["import React, { Component, ChangeEvent } from 'react';\nimport * as xmlParser from 'fast-xml-parser';\n\nexport interface GpxFormProps {\n  onChange: (gpxPoints: GpxPoint[]) => void;\n}\n\nexport interface GpxPoint {\n  lat: number;\n  lon: number;\n  ele: number;\n  time: Date;\n}\n\ninterface GpxRawPoint {\n  lat: string;\n  lon: string;\n  ele: number;\n  time: string;\n}\n\nexport class GpxForm extends Component<GpxFormProps> {\n  constructor(props) {\n    super(props);\n\n    this.handleFileChange = this.handleFileChange.bind(this);\n  }\n\n  async handleFileChange(event: ChangeEvent<HTMLInputElement>) {\n    const files = event.target.files;\n    if (!files || !files[0]) {\n      this.props.onChange([]);\n      return;\n    }\n\n    const points = await GpxForm.convertFileToGpxPoints(files[0]);\n    this.props.onChange(points);\n  }\n\n  static convertFileToGpxPoints(file: File): Promise<GpxPoint[]> {\n    const reader = new FileReader();\n\n    return new Promise((resolve, reject) => {\n      reader.onload = event => {\n        const result = event.target && event.target['result'];\n        if (!result) {\n          reject('convertFileToGpxPoints: empty file');\n        }\n\n        const jsonObj = xmlParser.parse(reader.result as string, {\n          attributeNamePrefix: '',\n          ignoreAttributes: false\n        });\n\n        const rawPoints = jsonObj.gpx.trk.trkseg.trkpt as GpxRawPoint[];\n        const points = rawPoints.map(rawPoint => ({\n          lat: parseFloat(rawPoint.lat),\n          lon: parseFloat(rawPoint.lon),\n          ele: rawPoint.ele,\n          time: new Date(rawPoint.time)\n        }));\n\n        resolve(points);\n      };\n\n      reader.onerror = () => reject('convertFileToGpxPoints: unknown error');\n      reader.onabort = () => reject('convertFileToGpxPoints: abort');\n\n      reader.readAsText(file);\n    });\n  }\n\n  render() {\n    return (\n      <form>\n        <input type=\"file\" onChange={this.handleFileChange} accept=\".gpx\" />\n      </form>\n    );\n  }\n}\n","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport React from \"react\";\n\nvar _ref2 =\n/*#__PURE__*/\nReact.createElement(\"path\", {\n  d: \"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z\"\n});\n\nvar SvgIcon = function SvgIcon(_ref) {\n  var svgRef = _ref.svgRef,\n      title = _ref.title,\n      props = _objectWithoutProperties(_ref, [\"svgRef\", \"title\"]);\n\n  return React.createElement(\"svg\", _extends({\n    width: 24,\n    height: 24,\n    viewBox: \"0 0 24 24\",\n    ref: svgRef\n  }, props), React.createElement(\"title\", null, title), _ref2);\n};\n\nvar ForwardRef = React.forwardRef(function (props, ref) {\n  return React.createElement(SvgIcon, _extends({\n    svgRef: ref\n  }, props));\n});\nexport default __webpack_public_path__ + \"static/media/icon.c5c4dbb6.svg\";\nexport { ForwardRef as ReactComponent };","import React, { Component } from 'react';\nimport { ReactComponent as Icon } from './assets/icon.svg';\nimport './message-box.component.scss';\n\nexport interface MessageBoxProps {\n  text: string;\n}\n\nexport class MessageBox extends Component<MessageBoxProps> {\n  render() {\n    return (\n      <div className=\"message-box\">\n        <div className=\"message-box__icon\">\n          <Icon />\n        </div>\n        <div className=\"message-box__text\">{this.props.text}</div>\n      </div>\n    );\n  }\n}\n","import React, { Component, ChangeEvent } from 'react';\nimport * as piexifjs from 'piexifjs';\nimport { MessageBox } from '../message-box/message-box.component';\nimport './images-form.component.scss';\n\nexport interface FormImage {\n  thumbnailUrl: string;\n  name: string;\n  lastModified: Date;\n  gps?: {\n    lat: number;\n    lon: number;\n  };\n  originalDataUrl: string;\n}\n\ninterface StaticImageFile {\n  dataUrl: string;\n  name: string;\n  lastModified: Date;\n}\n\ninterface ImagesFormProps {\n  onImagesChange: (images: FormImage[]) => void;\n}\n\nexport class ImagesForm extends Component<ImagesFormProps> {\n  constructor(props) {\n    super(props);\n\n    this.handleImageChange = this.handleImageChange.bind(this);\n  }\n\n  async handleImageChange(event: ChangeEvent<HTMLInputElement>) {\n    const files = event.target.files;\n    if (!files || !files[0]) {\n      this.props.onImagesChange([]);\n      return;\n    }\n\n    const imageFilesPromises = Array.from(files).map(file =>\n      ImagesForm.convertFileToDataUrl(file)\n    );\n    const imageFiles = await Promise.all(imageFilesPromises);\n\n    const imagesPromises: Promise<FormImage>[] = imageFiles.map(\n      async imageFile => {\n        const result: FormImage = {\n          thumbnailUrl: await ImagesForm.resizeImage(\n            imageFile.dataUrl,\n            200,\n            200\n          ),\n          name: imageFile.name,\n          lastModified: imageFile.lastModified,\n          originalDataUrl: imageFile.dataUrl\n        };\n\n        const exifData = piexifjs.load(imageFile.dataUrl);\n        const latDms = exifData.GPS[piexifjs.GPSIFD.GPSLatitude];\n        const lonDms = exifData.GPS[piexifjs.GPSIFD.GPSLongitude];\n\n        if (latDms && lonDms) {\n          const lat = piexifjs.GPSHelper.dmsRationalToDeg(latDms);\n          const lon = piexifjs.GPSHelper.dmsRationalToDeg(lonDms);\n\n          result.gps = {\n            lat,\n            lon\n          };\n        }\n\n        return result;\n      }\n    );\n    const images = await Promise.all(imagesPromises);\n\n    this.props.onImagesChange(images);\n  }\n\n  static async resizeImage(\n    url: string,\n    maxWidth: number,\n    maxHeight: number\n  ): Promise<string> {\n    const sourceImage = new Image();\n\n    return new Promise((resolve, reject) => {\n      sourceImage.onload = () => {\n        const proportionRatio =\n          sourceImage.width > sourceImage.height\n            ? maxWidth / sourceImage.width\n            : maxHeight / sourceImage.height;\n        const proportionalWidth = sourceImage.width * proportionRatio;\n        const proportionalHeight = sourceImage.height * proportionRatio;\n\n        // Create a canvas with the desired dimensions\n        var canvas = document.createElement('canvas');\n        canvas.width = proportionalWidth;\n        canvas.height = proportionalHeight;\n\n        // Scale and draw the source image to the canvas\n        const context = canvas.getContext('2d');\n        if (!context) {\n          reject('resizeImage: context is null');\n          return;\n        }\n        context.drawImage(\n          sourceImage,\n          0,\n          0,\n          proportionalWidth,\n          proportionalHeight\n        );\n\n        // Convert the canvas to a data URL in PNG format\n        resolve(canvas.toDataURL());\n      };\n      sourceImage.onerror = () => reject('resizeImage: unknown error');\n      sourceImage.onabort = () => reject('resizeImage: abort');\n\n      sourceImage.src = url;\n    });\n  }\n\n  static convertFileToDataUrl(file: File): Promise<StaticImageFile> {\n    const reader = new FileReader();\n\n    return new Promise((resolve, reject) => {\n      reader.onload = event => {\n        const result = event.target && event.target['result'];\n        if (!result) {\n          reject('convertFileToDataUrl: empty file');\n        }\n\n        resolve({\n          dataUrl: (result as string) || '',\n          name: file.name,\n          lastModified: new Date(file.lastModified)\n        });\n      };\n\n      reader.onerror = () => reject('convertFileToDataUrl: unknown error');\n      reader.onabort = () => reject('convertFileToDataUrl: abort');\n\n      reader.readAsDataURL(file);\n    });\n  }\n\n  render() {\n    return (\n      <form className=\"images-form\">\n        <input\n          className=\"images-form__input\"\n          type=\"file\"\n          multiple\n          onChange={this.handleImageChange}\n          accept=\".jpg,.jpeg\"\n        />\n\n        <MessageBox\n          text={\n            'There are no limits in number of images but if yours are large and you have many of them it may take more time to load.'\n          }\n        />\n        <MessageBox\n          text={\n            'It is better not to mix photos from different cameras. Their internal clock might not be synchronized. See \"How it works\" below for additional information.'\n          }\n        />\n        <MessageBox\n          text={\n            'You can choose photos files before GPX file to see photos with existing GPS data on map.'\n          }\n        />\n      </form>\n    );\n  }\n}\n","import { Component } from 'react';\nimport React from 'react';\nimport { FormImage } from '../images-form/images-form.component';\nimport * as piexifjs from 'piexifjs';\nimport JSZip from 'jszip';\nimport { saveAs } from 'file-saver';\nimport './geotag-download.component.scss';\nimport { MessageBox } from '../message-box/message-box.component';\n\nexport interface GeotagDownloadProps {\n  images: FormImage[];\n}\n\ninterface ExpandedBlob {\n  blob: Blob;\n  fileName: string;\n}\n\nexport class GeotagDownload extends Component<GeotagDownloadProps> {\n  constructor(props) {\n    super(props);\n\n    this.handleDownload = this.handleDownload.bind(this);\n  }\n\n  async handleDownload() {\n    const zip = new JSZip();\n\n    for (const image of this.props.images) {\n      const blob = await GeotagDownload.createBlobWithGps(image);\n      zip.file(blob.fileName, blob.blob);\n    }\n\n    const zipBlob = await zip.generateAsync({ type: 'blob' });\n    saveAs(zipBlob, 'geotagged-photos.zip');\n  }\n\n  static async createBlobWithGps(image: FormImage): Promise<ExpandedBlob> {\n    const exifData = piexifjs.load(image.originalDataUrl);\n    if (image.gps) {\n      exifData.GPS[\n        piexifjs.GPSIFD.GPSLatitude\n      ] = piexifjs.GPSHelper.degToDmsRational(image.gps.lat);\n      exifData.GPS[\n        piexifjs.GPSIFD.GPSLongitude\n      ] = piexifjs.GPSHelper.degToDmsRational(image.gps.lon);\n      exifData.GPS[piexifjs.GPSIFD.GPSVersionID] = [2, 2, 0, 0];\n      exifData.GPS[piexifjs.GPSIFD.GPSLatitudeRef] =\n        image.gps.lat < 0 ? 'S' : 'N';\n      exifData.GPS[piexifjs.GPSIFD.GPSLongitudeRef] =\n        image.gps.lon < 0 ? 'W' : 'E';\n    }\n\n    const exifStr = piexifjs.dump(exifData);\n    const updatedDataUrl = piexifjs.insert(exifStr, image.originalDataUrl);\n    const updatedBlob = await fetch(updatedDataUrl).then(res => res.blob());\n\n    return {\n      blob: updatedBlob,\n      fileName: image.name\n    };\n  }\n\n  render() {\n    return (\n      <div className=\"geotag-download\">\n        <MessageBox\n          text={\n            \"Existing GPS data will be replaced. Files outside GPS range won't be modified.\"\n          }\n        />\n        <button\n          onClick={this.handleDownload}\n          className=\"geotag-download__button\"\n        >\n          Download .zip file\n        </button>\n      </div>\n    );\n  }\n}\n","import React, { Component, ChangeEvent } from 'react';\nimport './offset-control.component.scss';\n\nexport interface OffsetControlProps {\n  onChange(offsetSecs: number): void;\n}\n\ninterface OffsetControlState {\n  offset: number;\n}\n\nexport class OffsetControl extends Component<\n  OffsetControlProps,\n  OffsetControlState\n> {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      offset: 0\n    };\n\n    this.handleOffsetChange = this.handleOffsetChange.bind(this);\n    this.handleOffsetDiff = this.handleOffsetDiff.bind(this);\n  }\n\n  handleOffsetChange(event: ChangeEvent<HTMLInputElement>) {\n    const value = parseInt(event.target.value);\n    this.setState(\n      {\n        offset: value\n      },\n      () => {\n        this.props.onChange(value);\n      }\n    );\n  }\n\n  handleOffsetDiff(offsetDiff: number): () => void {\n    return () => {\n      const newOffset = this.state.offset + offsetDiff;\n      this.setState(\n        {\n          offset: newOffset\n        },\n        () => {\n          this.props.onChange(newOffset);\n        }\n      );\n    };\n  }\n\n  render() {\n    return (\n      <div className=\"offset-control\">\n        <div className=\"offset-control__label\">offset in seconds</div>\n        <div className=\"offset-control__inputs\">\n          <button\n            className=\"offset-control__button\"\n            onClick={this.handleOffsetDiff(-60)}\n          >\n            -60\n          </button>\n          <button\n            className=\"offset-control__button\"\n            onClick={this.handleOffsetDiff(-1)}\n          >\n            -1\n          </button>\n          <input\n            className=\"offset-control__input\"\n            type=\"number\"\n            value={this.state.offset}\n            onChange={this.handleOffsetChange}\n          />\n          <button\n            className=\"offset-control__button\"\n            onClick={this.handleOffsetDiff(1)}\n          >\n            +1\n          </button>\n          <button\n            className=\"offset-control__button\"\n            onClick={this.handleOffsetDiff(60)}\n          >\n            +60\n          </button>\n        </div>\n      </div>\n    );\n  }\n}\n","import React, { Component } from 'react';\nimport {\n  Map,\n  Marker,\n  Popup,\n  TileLayer,\n  Polyline,\n  LatLngBounds\n} from 'react-leaflet';\nimport './images-map.component.scss';\nimport 'leaflet/dist/leaflet.css';\nimport { FormImage } from '../../images-form/images-form.component';\nimport L from 'leaflet';\nimport { GpxPoint } from '../../gpx-form/gpx-form.component';\n\ndelete L.Icon.Default.prototype._getIconUrl;\n\nL.Icon.Default.mergeOptions({\n  iconRetinaUrl: require('leaflet/dist/images/marker-icon-2x.png'),\n  iconUrl: require('leaflet/dist/images/marker-icon.png'),\n  shadowUrl: require('leaflet/dist/images/marker-shadow.png')\n});\n\nexport interface ImagesMapProps {\n  images: FormImage[];\n  points: GpxPoint[];\n}\n\nexport class ImagesMap extends Component<ImagesMapProps> {\n  render() {\n    const linePoints = this.props.points.map(point => [point.lat, point.lon]);\n    let bounds: LatLngBounds = [[0, 0], [75, 180]];\n    if (linePoints.length > 1) {\n      bounds = [linePoints[0], linePoints[linePoints.length - 1]];\n    }\n\n    return (\n      <div className=\"images-map\">\n        <Map bounds={bounds}>\n          <TileLayer\n            url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\n            attribution='&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n          />\n          <Polyline positions={linePoints} />\n          {this.props.images\n            .filter(image => image.gps)\n            .map(image => {\n              return (\n                <Marker\n                  position={image.gps && [image.gps.lat, image.gps.lon]}\n                  key={image.name}\n                >\n                  <Popup>\n                    <img src={image.thumbnailUrl} width=\"50\" alt={image.name} />\n                    <br />\n                    {image.name}\n                  </Popup>\n                </Marker>\n              );\n            })}\n        </Map>\n      </div>\n    );\n  }\n}\n","import React, { Component } from 'react';\nimport { OffsetControl } from './offset-control/offset-control.component';\nimport { ImagesMap } from './images-map/images-map.component';\nimport { FormImage } from '../images-form/images-form.component';\nimport { GpxPoint } from '../gpx-form/gpx-form.component';\nimport './correlate-step.component.scss';\nimport { MessageBox } from '../message-box/message-box.component';\n\nexport interface CorrelateStepProps {\n  images: FormImage[];\n  points: GpxPoint[];\n  onOffsetChange: (offsetSecs: number) => void;\n}\n\nexport class CorrelateStep extends Component<CorrelateStepProps> {\n  render() {\n    const imagesOutsideRange = this.props.images.filter(image => !image.gps);\n    return (\n      <section className=\"g-step\">\n        <h2 className=\"g-step__title\">Corelate time</h2>\n        <OffsetControl onChange={this.props.onOffsetChange} />\n        <ImagesMap images={this.props.images} points={this.props.points} />\n\n        {imagesOutsideRange.length > 0 && (\n          <div className=\"outside-range\">\n            <h3 className=\"outside-range__title\">\n              Images with dates outside GPX range\n            </h3>\n            <div className=\"outside-range__list\">\n              {imagesOutsideRange.map(image => (\n                <img\n                  className=\"outside-range__image\"\n                  src={image.thumbnailUrl}\n                  width=\"50\"\n                  alt={image.name}\n                  title={image.name}\n                  key={image.name}\n                />\n              ))}\n            </div>\n          </div>\n        )}\n\n        <MessageBox text=\"Your GPX recorder (f.e. phone) and your camera might not share the same time. Check your photos and update offset if necessary.\" />\n      </section>\n    );\n  }\n}\n","import React, { Component } from 'react';\nimport './app.component.scss';\nimport { GpxForm, GpxPoint } from './gpx-form/gpx-form.component';\nimport { ImagesForm, FormImage } from './images-form/images-form.component';\nimport { GeotagDownload } from './geotag-download/geotag-download.component';\nimport { CorrelateStep } from './correlate-step/correlate-step.component';\n\ninterface AppState {\n  images: FormImage[];\n  points: GpxPoint[];\n  offsetSecs: number;\n}\n\nexport class App extends Component<{}, AppState> {\n  static maxGpsTimeframeSecs = 15 * 60;\n\n  constructor(props) {\n    super(props);\n\n    this.handleImagesChange = this.handleImagesChange.bind(this);\n    this.handleGpxChange = this.handleGpxChange.bind(this);\n    this.handleOffsetChange = this.handleOffsetChange.bind(this);\n\n    this.state = {\n      images: [],\n      points: [],\n      offsetSecs: 0\n    };\n  }\n\n  handleImagesChange(images: FormImage[]) {\n    this.setState(\n      {\n        images: images\n      },\n      () => {\n        this.updateImagesLocation();\n      }\n    );\n  }\n\n  handleGpxChange(points: GpxPoint[]) {\n    this.setState(\n      {\n        points\n      },\n      () => {\n        this.updateImagesLocation();\n      }\n    );\n  }\n\n  updateImagesLocation() {\n    const imagesWithGpx = this.state.images.map(image =>\n      App.attachGpsCoordinates(image, this.state.points, this.state.offsetSecs)\n    );\n\n    this.setState({\n      images: imagesWithGpx\n    });\n  }\n\n  handleOffsetChange(offsetSecs: number): void {\n    this.setState(\n      {\n        offsetSecs\n      },\n      () => {\n        this.updateImagesLocation();\n      }\n    );\n  }\n\n  static attachGpsCoordinates(\n    image: FormImage,\n    points: GpxPoint[],\n    offsetSecs: number = 0\n  ): FormImage {\n    // IMPROVEMENT: consider updating algorithm to find midpoint (points can be far apart if travelling fast)\n    const lastModifiedWithOffset = new Date(\n      image.lastModified.getTime() + offsetSecs * 1000\n    );\n\n    // IMPROVEMENT: check if points are always sorted from oldest (in GPX spec) and consider breaking loop early\n    const timeframeSortedPoints = [...points].sort((pointA, pointB) => {\n      const timeframeSecsA = calculateTimeframeSecs(pointA);\n      const timeframeSecsB = calculateTimeframeSecs(pointB);\n      return timeframeSecsA - timeframeSecsB;\n    });\n\n    const closestPoint =\n      timeframeSortedPoints[0] &&\n      calculateTimeframeSecs(timeframeSortedPoints[0]) <=\n        App.maxGpsTimeframeSecs\n        ? timeframeSortedPoints[0]\n        : undefined;\n\n    if (!closestPoint) {\n      return image;\n    }\n\n    return {\n      ...image,\n      gps: {\n        lat: closestPoint.lat,\n        lon: closestPoint.lon\n      }\n    };\n\n    function calculateTimeframeSecs(point: GpxPoint): number {\n      return (\n        Math.abs(point.time.getTime() - lastModifiedWithOffset.getTime()) / 1000\n      );\n    }\n  }\n\n  render() {\n    return (\n      <div className=\"geotag\">\n        <section className=\"g-header\">\n          <h1 className=\"g-header__title\">Geotag your photos</h1>\n          <h3 className=\"g-header__subtitle\">No upload needed</h3>\n        </section>\n\n        <div className=\"geotag__steps\">\n          <section className=\"g-step\">\n            <h2 className=\"g-step__title\">Select GPX file</h2>\n            <GpxForm onChange={this.handleGpxChange} />\n          </section>\n\n          <section className=\"g-step\">\n            <h2 className=\"g-step__title\">Pick .jpg photos</h2>\n            <ImagesForm onImagesChange={this.handleImagesChange} />\n          </section>\n\n          <CorrelateStep\n            images={this.state.images}\n            points={this.state.points}\n            onOffsetChange={this.handleOffsetChange}\n          />\n\n          <section className=\"g-step\">\n            <h2 className=\"g-step__title\">Finish</h2>\n            <GeotagDownload images={this.state.images} />\n          </section>\n\n          <section className=\"g-step\">\n            <h2 className=\"g-step__title\">Read more</h2>\n\n            <h4>About project</h4>\n            <p>\n              This is side-project that I built because I couldn't find good\n              enough solution to geotag my photos. It doesn't require any\n              upload. Images are processed inside your browser.\n            </p>\n            <p>\n              If you find it useful or the exact opposite - it doesn't work for\n              you - let me know (see author section).\n            </p>\n            <p>\n              Code is open sourced so feel free to inspect it or contribute on{' '}\n              <a href=\"https://github.com/aqum/gpx-image-geotag\">Github</a>\n            </p>\n\n            <h4>What is GPX file?</h4>\n            <p>\n              GPX file is basically collection of coordinates and timestamps. Is\n              is structurized using XML tags so computer can parse it more\n              easily. You can open it in text editor and see for yourself.\n            </p>\n            <p>Here is sample line from GPX file:</p>\n            <code>\n              <pre>\n                {`<trkpt lat=\"50.8761400\" lon=\"15.1888720\">\n  <ele>377.5</ele>\n  <time>2019-08-17T09:49:06Z</time>\n</trkpt>`}\n              </pre>\n            </code>\n\n            <h4>How it works?</h4>\n            <p>\n              Your photo has creation date. Based on this we can look for\n              closest timestamp in GPX file. Then we take coordinates and write\n              them to jpeg metadata known also as{' '}\n              <a href=\"https://pl.wikipedia.org/wiki/Exchangeable_Image_File_Format\">\n                Exif\n              </a>\n              .\n            </p>\n            <p>\n              Of course you can do it yourself but with this app it is much\n              faster. Isn't it? ;)\n            </p>\n\n            <h4>Author</h4>\n            <p>\n              My name is Adam Florczak. I'm based in Warsaw (Poland) and I do\n              programming for a living.\n            </p>\n            <p>\n              Here is blog (in Polish) about my trips:{' '}\n              <a href=\"https://rowerotopia.pl\">rowerotopia.pl</a>\n            </p>\n            <p>My email: adam.florczak [at] me.com</p>\n            <p>\n              <a href=\"https://www.linkedin.com/in/adam-florczak-4379b692/\">\n                Linkedin\n              </a>\n            </p>\n          </section>\n        </div>\n      </div>\n    );\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport { App } from './app.component';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}